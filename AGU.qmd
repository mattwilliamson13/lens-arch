---
title: "AGU archetype analysis"
author: "Matt Williamson"
format: html
editor: visual
---

## Data Sources

Meredith will ultimately need to provide the info on the various input datasets, but I'm leaving a place for it here.

## Data Processing

In order to include the AOP-generated canopy height and leaf area index estimates, I had to join some of the data from the first LENS meeting (at SESYNC; `aop.vars`) to the data that Meredith processed (`database1202`). Because the siteID's in the original data don't align with those in Meredith's data, I had to process those here as well.

```{r}
library(ggbiplot)
library(tidyverse)
library(softImpute)
library(ggsci)
library(factoextra)
library(sf)
aopvars <- c("chm_mean", "chm_std", "lai_mean", "lai_std")
aop.vars <- read_csv("data/original/NEON-AOP-Mergeddata.csv") %>% select(., c(Site, aopvars)) %>% 
  mutate(., siteID = substr(Site, 5, 8))

database1202 <- read_csv("data/original/AOP_Database_12_2_Terrestrial.csv") %>% 
  left_join(., aop.vars) 
  
```

## Subsetting the Data by Topic

I used the data selection spreadsheet that we discussed on Google Drive to subset the variables based on those we identified (i.e., those where `Don == 1`). I then classified each variable into one of four categories: `identifying`, `biophysical`, `disturbance`, and `social`. Finally, I created two different datasets. One that included `identifying`, `biophysical`, and `disturbance` variables and one that included all of the identified variables (including `social`). Due to the presence of missing data, I used the full dataset as the basis for imputing missing data before subsetting the data into the biophysical data frame. I imputed the data using `softImpute,` a method that uses nuclear-norm regularization to fill in missing values using a soft-thresholded Single Value Decomposition. All data were scaled and centered for imputation.

```{r}
data.list <- read.csv("data/original/LENS_database_variables.csv") %>% 
  filter(., Don == "1")

variables.biophys.dist <- data.list %>% 
  filter(., Analysis %in% c("Identifying", "Biophys", "Disturbance"))

#generate the search strings
Pattern.biophys.dist <- paste(str_trim(variables.biophys.dist$Variable), collapse = "|")
Pattern.all <- paste(str_trim(data.list$Variable), collapse = "|")

vars2use.biophys <- grep(Pattern.biophys.dist, colnames(database1202),ignore.case=TRUE,value=TRUE)
vars2use.all <- grep(Pattern.all, colnames(database1202),ignore.case=TRUE,value=TRUE)
#refine the search string to exclude partial matches
vars2use.biophys <- subset(vars2use.biophys, (vars2use.biophys %in% variables.biophys.dist$Variable))
vars2use.all <- subset(vars2use.all, (vars2use.all %in% data.list$Variable))

## filter the full dataset
database.all <- database1202 %>% 
  select(., all_of(c("domain", "domainName", "siteName", "siteID", vars2use.all)))

## Impute missing values
fit <-softImpute(as.matrix(database.all[,-c(1:4)]), rank.max = 40, lambda = 49, type = "svd", thresh = 1e-09)
aop.impute <- complete(as.matrix(database.all[,-c(1:4)]), fit,  unscale = TRUE)
aop.subset.vars.scl <- biScale(as.matrix(aop.impute), maxit = 1000, trace = TRUE)

database.impute <- cbind(database.all[, c(1:4)], aop.subset.vars.scl)

#filter the imputed data for the biophysical dataset
database.biophys <- database.impute %>% 
  select(., all_of(c("domain", "domainName", "siteName", "siteID", vars2use.biophys)))
```

## Generating Clusters

Based on our discussion the goal was to identify 8 clusters and compare the resulting groupings. Clustering looks to find homogeneous subgroups within the data. *K-means* clustering seeks to partition the data into a set number of clusters while *hierarchical clustering* does not have an *a priori* assumed number of clusters. *K-means* clustering seeks to minimize the amount of within-cluster variation and achieves clustering that is locally optimal based on the initial assignment of observations to clusters. The bottom-up agglomeration method for hierarchical clustering (the one I used) parses each site into the finest set of clusters and then combines them into larger and larger clusters as one moves up the tree. Clusters are defined based on a dissimilarity metric (i.e., the distance of observations from one another in multivariate space or the shape of the correlation profile within each set of observations). Because the data are measured on different scales, I used the centered and scaled values (i.e., mean=0 and sd=1). This assumes that each variable has the potential to be equally important in the clusters. I ran a k-means and hierarchical clusters based on both distance and correlation in case they are of interest.

### K-Means Clusters

K-means plots are generated by combining variables using PCA and then plotting the clusters. Note that with this many variables, the initial PCA axes do not capture much of the overall variation.

```{r}
biophys.kmeans <- kmeans(database.biophys[,-c(1:4)], 8, nstart = 50)
biophys.plot.mat <- database.biophys[,-c(1:4)]
rownames(biophys.plot.mat) <- database.biophys$siteID

fviz_cluster(biophys.kmeans, data = biophys.plot.mat,
             stand=FALSE,
             palette = pal_ucscgb()(8), 
             geom = "text",
             repel=TRUE,
             ellipse.type = "convex", 
             main="K-means for Biophysical and Disturbance Data",
             ggtheme = theme_bw()
             )
```
```{r}
all.kmeans <- kmeans(database.impute[,-c(1:4)], 8, nstart = 50)
all.plot.mat <- database.impute[,-c(1:4)]
rownames(all.plot.mat) <- database.impute$siteID

fviz_cluster(all.kmeans, data = all.plot.mat,
             stand=FALSE,
             palette = pal_ucscgb()(8), 
             geom = "text",
             repel=TRUE,
             ellipse.type = "convex", 
             main="K-means for Socio-Ecological Data",
             ggtheme = theme_bw()
             )
```

### Hierarchical Clusters Based on Distance

I used the complete linkage hierarchical clustering algorithm which maximizes the intercluster dissimilarity based on the Euclidean distance.
```{r}
dist.clust.biophys <- hclust(dist(database.biophys[,-c(1:4)]),  "complete")

dist.clust.all <- hclust(dist(database.impute[,-c(1:4)]),  "complete")

plot(dist.clust.biophys, labels = database.biophys$siteID, xlab = "", ylab = "", sub = "", main="Distance-Based Cluster for Biophysical and Disturbance Data")

rect.hclust(dist.clust.biophys, k = 8, border = pal_ucscgb()(8))

plot(dist.clust.all, labels = database.impute$siteID, xlab = "", ylab = "", sub = "", main="Distance-Based Cluster for Socio-Ecological Data")

rect.hclust(dist.clust.all, k = 8, border = pal_ucscgb()(8))
```

### Hierarchical Clusters Based on Correlation

```{r}
cor.clust.biophys <- hclust(as.dist(1-cor(t(database.biophys[,-c(1:4)]))),  "complete")

cor.clust.all <- hclust(as.dist(1 -cor(t(database.impute[,-c(1:4)]))),  "complete")

plot(cor.clust.biophys, labels = database.biophys$siteID, xlab = "", ylab = "", sub = "", main="Correlation-Based Cluster for Biophysical and Disturbance Data")

rect.hclust(cor.clust.biophys, k = 8, border = pal_ucscgb()(8))

plot(cor.clust.all, labels = database.impute$siteID, xlab = "", ylab = "", sub = "", main="Correlation-Based Cluster for Socio-Ecological Data")

rect.hclust(cor.clust.all, k = 8, border = pal_ucscgb()(8))
```

## Creating Spatial Data of Clusters

```{r}
aop.footprint <- st_read("data/original/NEON-AOP-FlightBoxes.shp") %>% 
  mutate(., siteID = substr(Site, 5, 8)) %>% st_centroid()

group.dist.clust.biophys <- cutree(dist.clust.biophys, k = 8)
group.dist.clust.all <- cutree(dist.clust.all, k = 8)
group.cor.clust.biophys <- cutree(cor.clust.biophys, k = 8)
group.cor.clust.all <- cutree(cor.clust.all, k = 8)
group.kmeans.biophys <- biophys.kmeans$cluster 
group.kmeans.all <- all.kmeans$cluster

database.group <- database.impute %>% 
  bind_cols(., "SEClustDist" = group.dist.clust.all, "BiophysClustDist" = group.dist.clust.biophys, "SEClustCor" = group.cor.clust.all,
            "BiophysClustCor" = group.cor.clust.biophys,
            "SEKmeans" = group.kmeans.all, "BiophysKmeans" = group.kmeans.biophys) 

aop.join <- aop.footprint %>% 
  right_join(database.group) %>% 
  filter(., siteID != "BARR") %>% 
  select(, c(1:6, 113:119))

st_write(st_as_sf(aop.join), here::here("data/processed/aop_clusters.shp"), append = FALSE)

```

## Identifying Important Variables

Archetypes inherently recognize that no single variable is likely to be responsible for the grouping of SE systems. Moreover, because clusters are formed based on the position of sites in multivariate space, it is unlikely that any single variable is solely responsible for the grouping or splitting of sites (unlike a random forest tree). As such, attempting feature selection (i.e., the identification of singular important variables) is a slightly counterintuitive exercise. Rather than identifying the variables responsible for the groups, I chose to identify which principle components explained up to 80% of the variation in the data and then summed the absolute value of the loadings of those variables to characterize the role of the different variables in parsing out the multivariate space.

I used the cumulative proportion of variance explained (PVE) to identify which PCs where necessary to explain 80% of the variation in each dataset (1:14 for the biophysical and 1:15 for the social-ecological data),

```{r}
pr.biophys <- prcomp(database.biophys[,-c(1:4)] , scale = FALSE)
pve.biophys <-pr.biophys$sdev^2 / sum(pr.biophys$sdev^2)
plot(cumsum(pve.biophys), xlab = "Principal Component",
ylab = "Cumulative Proportion of Variance Explained",
ylim = c(0, 1), type = "b", main="PVE for Biophysical PCA")

biophys.rot <- as.data.frame(abs(pr.biophys$rotation[,1:14])) 

biophys.rot$cumulative <-  rowSums(biophys.rot[,1:14])

biophys.rot$prop <- unlist(lapply(1:nrow(biophys.rot), function(x) biophys.rot[x,"cumulative"]/sum(biophys.rot$cumulative))) 

biophys.rot %>% 
  arrange(desc(prop)) %>% 
  slice(1:10) %>%
  rownames()
  

pr.all <- prcomp(database.impute[,-c(1:4)] , scale = FALSE)
pve.all <-pr.all$sdev^2 / sum(pr.all$sdev^2)
plot(cumsum(pve.all), xlab = "Principal Component",
ylab = "Cumulative Proportion of Variance Explained",
ylim = c(0, 1), type = "b", main="PVE for Social-Ecological PCA")

all.rot <- as.data.frame(abs(pr.all$rotation[,1:15])) 

all.rot$cumulative <-  rowSums(all.rot[,1:15])

all.rot$prop <- unlist(lapply(1:nrow(all.rot), function(x) all.rot[x,"cumulative"]/sum(all.rot$cumulative))) 

all.rot %>% 
  arrange(desc(prop)) %>% 
  slice(1:10) %>% 
  rownames()

```
